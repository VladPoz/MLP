{"ast":null,"code":"/** Text hyphenation in Javascript.\n *  Copyright (C) 2025 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  function createTextReader(setup) {\n    var char1 = \"\";\n    var char2 = \"\";\n    var i = 0;\n    var verifier = setup();\n    return function (text) {\n      while (i < text.length) {\n        char1 = text.charAt(i++);\n        char2 = text.charAt(i);\n        var verified = verifier(char1, char2);\n        if (verified !== void 0) {\n          return verified;\n        }\n      }\n    };\n  }\n  var isNotLetter = RegExp.prototype.test.bind(/\\s|(?![\\'])[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/);\n  function createHTMLVerifier() {\n    var skip = false;\n    return function (accumulate, chars) {\n      if (skip) {\n        if (chars[0] === \">\") {\n          accumulate();\n          skip = false;\n        }\n      } else if (chars[0] === \"<\" && (!isNotLetter(chars[1]) || chars[1] === \"/\")) {\n        skip = true;\n      }\n      return skip;\n    };\n  }\n  function createHyphenCharVerifier(hyphenChar) {\n    var skip = false;\n    return function (accumulate, chars) {\n      if (skip) {\n        if (!isNotLetter(chars[0]) && isNotLetter(chars[1])) {\n          accumulate();\n          skip = false;\n        }\n      } else if (!isNotLetter(chars[0]) && chars[1] === hyphenChar) {\n        skip = true;\n      }\n      return skip;\n    };\n  }\n  function createHyphenationVerifier(verifiers, minWordLength) {\n    return function () {\n      var accum0 = \"\";\n      var accum = \"\";\n      function accumulate() {\n        accum0 += accum;\n        accum = \"\";\n      }\n      function resolveWith(value) {\n        accum0 = \"\";\n        accum = \"\";\n        return value;\n      }\n      return function (char1, char2) {\n        accum += char1;\n        var skip = verifiers.reduce(function (skip2, verify) {\n          return skip2 || verify(accumulate, [char1, char2]);\n        }, false);\n        if (!skip) {\n          if (isNotLetter(char1) && !isNotLetter(char2)) {\n            accumulate();\n          }\n          if (!isNotLetter(char1) && isNotLetter(char2)) {\n            if (accum.length >= minWordLength) {\n              return resolveWith([accum0, accum]);\n            } else {\n              accumulate();\n            }\n          }\n        }\n        if (char2 === \"\") {\n          if (accum.length < minWordLength || skip) {\n            accumulate();\n          }\n          return resolveWith([accum0, accum]);\n        }\n      };\n    };\n  }\n  function levelsToMarkers(levels) {\n    var markers = [];\n    for (var i = 0; i < levels.length; i++) if ((levels[i] & 1) === 1) markers.push(i);\n    return markers;\n  }\n  function insertChar(text, hyphenChar, markers) {\n    if (markers.length === 0) {\n      return text;\n    }\n    var resultText = [text.slice(0, markers[0])];\n    if (markers.length > 1) for (var i = 0, j = 1; j < markers.length; i++, j++) {\n      resultText.push(text.slice(markers[i], markers[j]));\n    }\n    resultText.push(text.slice(markers[markers.length - 1]));\n    return resultText.join(hyphenChar);\n  }\n  function markersFromExceptionsDefinition(exceptionsList) {\n    return exceptionsList.reduce(function (markersDict, definition) {\n      var i = 0,\n        markers = [];\n      while ((i = definition.indexOf(\"-\", i + 1)) > -1) {\n        markers.push(i);\n      }\n      markersDict[definition.toLocaleLowerCase().replace(/\\-/g, \"\")] = markers;\n      return markersDict;\n    }, {});\n  }\n  function createCharIterator(str) {\n    var i = 0;\n    function nextChar() {\n      return str[i++];\n    }\n    return nextChar;\n  }\n  function createStringSlicer(str) {\n    var i = 0,\n      slice = str;\n    function next() {\n      slice = str.slice(i++);\n      if (slice.length < 3) {\n        return;\n      }\n      return slice;\n    }\n    function isFirstCharacter() {\n      return i === 2;\n    }\n    return [next, isFirstCharacter];\n  }\n  function hyphenateWord(text, loweredText, levelsTable, patternTrie) {\n    var levels = new Array(text.length + 1),\n      loweredText = (\".\" + loweredText + \".\").split(\"\"),\n      wordSlice,\n      letter,\n      triePtr,\n      trieNode,\n      patternLevelsIndex,\n      patternLevels,\n      patternEntityIndex = -1,\n      slicer,\n      nextSlice,\n      isFirstCharacter,\n      nextLetter;\n    for (var i = levels.length; i--;) levels[i] = 0;\n    slicer = createStringSlicer(loweredText);\n    nextSlice = slicer[0];\n    isFirstCharacter = slicer[1];\n    while (wordSlice = nextSlice()) {\n      patternEntityIndex++;\n      if (isFirstCharacter()) {\n        patternEntityIndex--;\n      }\n      triePtr = patternTrie;\n      nextLetter = createCharIterator(wordSlice);\n      while (letter = nextLetter()) {\n        if ((trieNode = triePtr[letter]) === void 0) {\n          break;\n        }\n        triePtr = {};\n        patternLevelsIndex = -1;\n        switch (Object.prototype.toString.call(trieNode)) {\n          case \"[object Array]\":\n            triePtr = trieNode[0];\n            patternLevelsIndex = trieNode[1];\n            break;\n          case \"[object Object]\":\n            triePtr = trieNode;\n            break;\n          case \"[object Number]\":\n            patternLevelsIndex = trieNode;\n            break;\n        }\n        if (patternLevelsIndex < 0) {\n          continue;\n        }\n        if (!levelsTable[patternLevelsIndex].splice) {\n          levelsTable[patternLevelsIndex] = levelsTable[patternLevelsIndex].slice(\"\");\n        }\n        patternLevels = levelsTable[patternLevelsIndex];\n        for (var k = 0; k < patternLevels.length; k++) levels[patternEntityIndex + k] = Math.max(patternLevels[k], levels[patternEntityIndex + k]);\n      }\n    }\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    return levelsToMarkers(levels);\n  }\n  function start(text, levelsTable, patterns, cache, markersDict, hyphenChar, skipHTML, minWordLength, isAsync) {\n    function done() {\n      resolveNewText(newText);\n    }\n    var newText = \"\",\n      fragments,\n      readText = createTextReader(createHyphenationVerifier((skipHTML ? [createHTMLVerifier()] : []).concat(createHyphenCharVerifier(hyphenChar)), minWordLength)),\n      resolveNewText = function () {};\n    function nextTick() {\n      var loopStart = /* @__PURE__ */new Date();\n      while ((!isAsync || /* @__PURE__ */new Date() - loopStart < 10) && (fragments = readText(text))) {\n        if (fragments[1]) {\n          var cacheKey = fragments[1].length ? \"~\" + fragments[1] : \"\";\n          if (!Object.prototype.hasOwnProperty.call(cache, cacheKey)) {\n            var loweredWord = fragments[1].toLocaleLowerCase();\n            if (!Object.prototype.hasOwnProperty.call(markersDict, loweredWord)) markersDict[loweredWord] = hyphenateWord(fragments[1], loweredWord, levelsTable, patterns);\n            cache[cacheKey] = insertChar(fragments[1], hyphenChar, markersDict[loweredWord]);\n          }\n          fragments[1] = cache[cacheKey];\n        }\n        newText += fragments[0] + fragments[1];\n      }\n      if (!fragments) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n  var SETTING_DEFAULT_ASYNC = false;\n  var SETTING_DEFAULT_EXCEPTIONS = [];\n  var SETTING_DEFAULT_HTML = true;\n  var SETTING_DEFAULT_HYPH_CHAR = \"\\xAD\";\n  var SETTING_DEFAULT_MIN_WORD_LENGTH = 5;\n  var SETTING_NAME_ASYNC = \"async\";\n  var SETTING_NAME_EXCEPTIONS = \"exceptions\";\n  var SETTING_NAME_HTML = \"html\";\n  var SETTING_NAME_HYPH_CHAR = \"hyphenChar\";\n  var SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n  var _global = typeof global === \"object\" ? global : typeof window === \"object\" ? window : typeof self === \"object\" ? self : false ? void 0 : {};\n  function extend(target, source) {\n    target = target || {};\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n  function validateArray(value) {\n    return value instanceof Array;\n  }\n  function keyOrDefault(object, key, defaultValue, test) {\n    if (key in object && (test ? test(object[key]) : true)) {\n      return object[key];\n    }\n    return defaultValue;\n  }\n  function exceptionsFromDefinition(exceptionsList, hyphenChar) {\n    return exceptionsList.reduce(function (exceptions, exception) {\n      exceptions[\"~\" + exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n      return exceptions;\n    }, {});\n  }\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var asyncMode = keyOrDefault(options, SETTING_NAME_ASYNC, SETTING_DEFAULT_ASYNC),\n      caches = {},\n      markersDict = {},\n      exceptions = {},\n      hyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, SETTING_DEFAULT_HYPH_CHAR),\n      levelsTable = patternsDefinition[0].split(\",\"),\n      patterns = JSON.parse(patternsDefinition[1]),\n      minWordLength = keyOrDefault(options, SETTING_NAME_MIN_WORD_LENGTH, SETTING_DEFAULT_MIN_WORD_LENGTH) >> 0,\n      skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML),\n      userExceptions = keyOrDefault(options, SETTING_NAME_EXCEPTIONS, SETTING_DEFAULT_EXCEPTIONS, validateArray);\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = {};\n    if (patternsDefinition[2]) {\n      exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition[2], hyphenChar);\n      markersDict = markersFromExceptionsDefinition(patternsDefinition[2]);\n    }\n    if (userExceptions && userExceptions.length) {\n      exceptions[cacheKey] = extend(exceptions[cacheKey], exceptionsFromDefinition(userExceptions, hyphenChar));\n      markersDict = extend(markersDict, markersFromExceptionsDefinition(userExceptions));\n    }\n    caches[cacheKey] = extend({}, exceptions[cacheKey]);\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\");\n    }\n    return function (text, options2) {\n      options2 = options2 || {};\n      var localHyphenChar = keyOrDefault(options2, SETTING_NAME_HYPH_CHAR, hyphenChar),\n        localMinWordLength = keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0,\n        localUserExceptions = keyOrDefault(options2, SETTING_NAME_EXCEPTIONS, SETTING_DEFAULT_EXCEPTIONS, validateArray),\n        cacheKey2 = localHyphenChar + localMinWordLength;\n      if (!exceptions[cacheKey2] && patternsDefinition[2]) {\n        exceptions[cacheKey2] = exceptionsFromDefinition(patternsDefinition[2], localHyphenChar);\n        caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);\n      }\n      if (localUserExceptions && localUserExceptions.length) {\n        exceptions[cacheKey2] = extend(exceptions[cacheKey2], exceptionsFromDefinition(localUserExceptions, localHyphenChar));\n        markersDict = extend(markersDict, markersFromExceptionsDefinition(localUserExceptions));\n        caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);\n      }\n      return start(text, levelsTable, patterns, caches[cacheKey2], markersDict, localHyphenChar, skipHTML, localMinWordLength, asyncMode);\n    };\n  }\n  return createHyphenator;\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","createHyphenator","createTextReader","setup","char1","char2","i","verifier","text","length","charAt","verified","isNotLetter","RegExp","prototype","test","bind","createHTMLVerifier","skip","accumulate","chars","createHyphenCharVerifier","hyphenChar","createHyphenationVerifier","verifiers","minWordLength","accum0","accum","resolveWith","value","reduce","skip2","verify","levelsToMarkers","levels","markers","push","insertChar","resultText","slice","j","join","markersFromExceptionsDefinition","exceptionsList","markersDict","definition","indexOf","toLocaleLowerCase","replace","createCharIterator","str","nextChar","createStringSlicer","next","isFirstCharacter","hyphenateWord","loweredText","levelsTable","patternTrie","Array","split","wordSlice","letter","triePtr","trieNode","patternLevelsIndex","patternLevels","patternEntityIndex","slicer","nextSlice","nextLetter","Object","toString","call","splice","k","Math","max","start","patterns","cache","skipHTML","isAsync","done","resolveNewText","newText","fragments","readText","concat","nextTick","loopStart","Date","cacheKey","hasOwnProperty","loweredWord","setTimeout","Promise","resolve","SETTING_DEFAULT_ASYNC","SETTING_DEFAULT_EXCEPTIONS","SETTING_DEFAULT_HTML","SETTING_DEFAULT_HYPH_CHAR","SETTING_DEFAULT_MIN_WORD_LENGTH","SETTING_NAME_ASYNC","SETTING_NAME_EXCEPTIONS","SETTING_NAME_HTML","SETTING_NAME_HYPH_CHAR","SETTING_NAME_MIN_WORD_LENGTH","_global","global","window","self","extend","target","source","key","validateArray","keyOrDefault","object","defaultValue","exceptionsFromDefinition","exceptions","exception","patternsDefinition","options","asyncMode","caches","JSON","parse","userExceptions","Error","options2","localHyphenChar","localMinWordLength","localUserExceptions","cacheKey2"],"sources":["C:/OSPanel/domains/MLP/node_modules/hyphen/hyphen.js"],"sourcesContent":["/** Text hyphenation in Javascript.\n *  Copyright (C) 2025 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  function createTextReader(setup) {\n    var char1 = \"\";\n    var char2 = \"\";\n    var i = 0;\n    var verifier = setup();\n    return function (text) {\n      while (i < text.length) {\n        char1 = text.charAt(i++);\n        char2 = text.charAt(i);\n        var verified = verifier(char1, char2);\n        if (verified !== void 0) {\n          return verified;\n        }\n      }\n    };\n  }\n\n  var isNotLetter = RegExp.prototype.test.bind(\n    /\\s|(?![\\'])[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/\n  );\n  function createHTMLVerifier() {\n    var skip = false;\n    return function (accumulate, chars) {\n      if (skip) {\n        if (chars[0] === \">\") {\n          accumulate();\n          skip = false;\n        }\n      } else if (\n        chars[0] === \"<\" &&\n        (!isNotLetter(chars[1]) || chars[1] === \"/\")\n      ) {\n        skip = true;\n      }\n      return skip;\n    };\n  }\n  function createHyphenCharVerifier(hyphenChar) {\n    var skip = false;\n    return function (accumulate, chars) {\n      if (skip) {\n        if (!isNotLetter(chars[0]) && isNotLetter(chars[1])) {\n          accumulate();\n          skip = false;\n        }\n      } else if (!isNotLetter(chars[0]) && chars[1] === hyphenChar) {\n        skip = true;\n      }\n      return skip;\n    };\n  }\n  function createHyphenationVerifier(verifiers, minWordLength) {\n    return function () {\n      var accum0 = \"\";\n      var accum = \"\";\n      function accumulate() {\n        accum0 += accum;\n        accum = \"\";\n      }\n      function resolveWith(value) {\n        accum0 = \"\";\n        accum = \"\";\n        return value;\n      }\n      return function (char1, char2) {\n        accum += char1;\n        var skip = verifiers.reduce(function (skip2, verify) {\n          return skip2 || verify(accumulate, [char1, char2]);\n        }, false);\n        if (!skip) {\n          if (isNotLetter(char1) && !isNotLetter(char2)) {\n            accumulate();\n          }\n          if (!isNotLetter(char1) && isNotLetter(char2)) {\n            if (accum.length >= minWordLength) {\n              return resolveWith([accum0, accum]);\n            } else {\n              accumulate();\n            }\n          }\n        }\n        if (char2 === \"\") {\n          if (accum.length < minWordLength || skip) {\n            accumulate();\n          }\n          return resolveWith([accum0, accum]);\n        }\n      };\n    };\n  }\n\n  function levelsToMarkers(levels) {\n    var markers = [];\n    for (var i = 0; i < levels.length; i++)\n      if ((levels[i] & 1) === 1) markers.push(i);\n    return markers;\n  }\n  function insertChar(text, hyphenChar, markers) {\n    if (markers.length === 0) {\n      return text;\n    }\n    var resultText = [text.slice(0, markers[0])];\n    if (markers.length > 1)\n      for (var i = 0, j = 1; j < markers.length; i++, j++) {\n        resultText.push(text.slice(markers[i], markers[j]));\n      }\n    resultText.push(text.slice(markers[markers.length - 1]));\n    return resultText.join(hyphenChar);\n  }\n  function markersFromExceptionsDefinition(exceptionsList) {\n    return exceptionsList.reduce(function (markersDict, definition) {\n      var i = 0,\n        markers = [];\n      while ((i = definition.indexOf(\"-\", i + 1)) > -1) {\n        markers.push(i);\n      }\n      markersDict[definition.toLocaleLowerCase().replace(/\\-/g, \"\")] = markers;\n      return markersDict;\n    }, {});\n  }\n\n  function createCharIterator(str) {\n    var i = 0;\n    function nextChar() {\n      return str[i++];\n    }\n    return nextChar;\n  }\n  function createStringSlicer(str) {\n    var i = 0,\n      slice = str;\n    function next() {\n      slice = str.slice(i++);\n      if (slice.length < 3) {\n        return;\n      }\n      return slice;\n    }\n    function isFirstCharacter() {\n      return i === 2;\n    }\n    return [next, isFirstCharacter];\n  }\n  function hyphenateWord(text, loweredText, levelsTable, patternTrie) {\n    var levels = new Array(text.length + 1),\n      loweredText = (\".\" + loweredText + \".\").split(\"\"),\n      wordSlice,\n      letter,\n      triePtr,\n      trieNode,\n      patternLevelsIndex,\n      patternLevels,\n      patternEntityIndex = -1,\n      slicer,\n      nextSlice,\n      isFirstCharacter,\n      nextLetter;\n    for (var i = levels.length; i--; ) levels[i] = 0;\n    slicer = createStringSlicer(loweredText);\n    nextSlice = slicer[0];\n    isFirstCharacter = slicer[1];\n    while ((wordSlice = nextSlice())) {\n      patternEntityIndex++;\n      if (isFirstCharacter()) {\n        patternEntityIndex--;\n      }\n      triePtr = patternTrie;\n      nextLetter = createCharIterator(wordSlice);\n      while ((letter = nextLetter())) {\n        if ((trieNode = triePtr[letter]) === void 0) {\n          break;\n        }\n        triePtr = {};\n        patternLevelsIndex = -1;\n        switch (Object.prototype.toString.call(trieNode)) {\n          case \"[object Array]\":\n            triePtr = trieNode[0];\n            patternLevelsIndex = trieNode[1];\n            break;\n          case \"[object Object]\":\n            triePtr = trieNode;\n            break;\n          case \"[object Number]\":\n            patternLevelsIndex = trieNode;\n            break;\n        }\n        if (patternLevelsIndex < 0) {\n          continue;\n        }\n        if (!levelsTable[patternLevelsIndex].splice) {\n          levelsTable[patternLevelsIndex] = levelsTable[\n            patternLevelsIndex\n          ].slice(\"\");\n        }\n        patternLevels = levelsTable[patternLevelsIndex];\n        for (var k = 0; k < patternLevels.length; k++)\n          levels[patternEntityIndex + k] = Math.max(\n            patternLevels[k],\n            levels[patternEntityIndex + k]\n          );\n      }\n    }\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[\n      levels.length - 2\n    ] = 0;\n    return levelsToMarkers(levels);\n  }\n\n  function start(\n    text,\n    levelsTable,\n    patterns,\n    cache,\n    markersDict,\n    hyphenChar,\n    skipHTML,\n    minWordLength,\n    isAsync\n  ) {\n    function done() {\n      resolveNewText(newText);\n    }\n    var newText = \"\",\n      fragments,\n      readText = createTextReader(\n        createHyphenationVerifier(\n          (skipHTML ? [createHTMLVerifier()] : []).concat(\n            createHyphenCharVerifier(hyphenChar)\n          ),\n          minWordLength\n        )\n      ),\n      resolveNewText = function () {};\n    function nextTick() {\n      var loopStart = /* @__PURE__ */ new Date();\n      while (\n        (!isAsync || /* @__PURE__ */ new Date() - loopStart < 10) &&\n        (fragments = readText(text))\n      ) {\n        if (fragments[1]) {\n          var cacheKey = fragments[1].length ? \"~\" + fragments[1] : \"\";\n          if (!Object.prototype.hasOwnProperty.call(cache, cacheKey)) {\n            var loweredWord = fragments[1].toLocaleLowerCase();\n            if (!Object.prototype.hasOwnProperty.call(markersDict, loweredWord))\n              markersDict[loweredWord] = hyphenateWord(\n                fragments[1],\n                loweredWord,\n                levelsTable,\n                patterns\n              );\n            cache[cacheKey] = insertChar(\n              fragments[1],\n              hyphenChar,\n              markersDict[loweredWord]\n            );\n          }\n          fragments[1] = cache[cacheKey];\n        }\n        newText += fragments[0] + fragments[1];\n      }\n      if (!fragments) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n\n  var SETTING_DEFAULT_ASYNC = false;\n  var SETTING_DEFAULT_EXCEPTIONS = [];\n  var SETTING_DEFAULT_HTML = true;\n  var SETTING_DEFAULT_HYPH_CHAR = \"\\xAD\";\n  var SETTING_DEFAULT_MIN_WORD_LENGTH = 5;\n  var SETTING_NAME_ASYNC = \"async\";\n  var SETTING_NAME_EXCEPTIONS = \"exceptions\";\n  var SETTING_NAME_HTML = \"html\";\n  var SETTING_NAME_HYPH_CHAR = \"hyphenChar\";\n  var SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n  var _global =\n    typeof global === \"object\"\n      ? global\n      : typeof window === \"object\"\n      ? window\n      : typeof self === \"object\"\n      ? self\n      : false\n      ? void 0\n      : {};\n  function extend(target, source) {\n    target = target || {};\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n  function validateArray(value) {\n    return value instanceof Array;\n  }\n  function keyOrDefault(object, key, defaultValue, test) {\n    if (key in object && (test ? test(object[key]) : true)) {\n      return object[key];\n    }\n    return defaultValue;\n  }\n  function exceptionsFromDefinition(exceptionsList, hyphenChar) {\n    return exceptionsList.reduce(function (exceptions, exception) {\n      exceptions[\"~\" + exception.replace(/\\-/g, \"\")] = exception.replace(\n        /\\-/g,\n        hyphenChar\n      );\n      return exceptions;\n    }, {});\n  }\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var asyncMode = keyOrDefault(\n        options,\n        SETTING_NAME_ASYNC,\n        SETTING_DEFAULT_ASYNC\n      ),\n      caches = {},\n      markersDict = {},\n      exceptions = {},\n      hyphenChar = keyOrDefault(\n        options,\n        SETTING_NAME_HYPH_CHAR,\n        SETTING_DEFAULT_HYPH_CHAR\n      ),\n      levelsTable = patternsDefinition[0].split(\",\"),\n      patterns = JSON.parse(patternsDefinition[1]),\n      minWordLength =\n        keyOrDefault(\n          options,\n          SETTING_NAME_MIN_WORD_LENGTH,\n          SETTING_DEFAULT_MIN_WORD_LENGTH\n        ) >> 0,\n      skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML),\n      userExceptions = keyOrDefault(\n        options,\n        SETTING_NAME_EXCEPTIONS,\n        SETTING_DEFAULT_EXCEPTIONS,\n        validateArray\n      );\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = {};\n    if (patternsDefinition[2]) {\n      exceptions[cacheKey] = exceptionsFromDefinition(\n        patternsDefinition[2],\n        hyphenChar\n      );\n      markersDict = markersFromExceptionsDefinition(patternsDefinition[2]);\n    }\n    if (userExceptions && userExceptions.length) {\n      exceptions[cacheKey] = extend(\n        exceptions[cacheKey],\n        exceptionsFromDefinition(userExceptions, hyphenChar)\n      );\n      markersDict = extend(\n        markersDict,\n        markersFromExceptionsDefinition(userExceptions)\n      );\n    }\n    caches[cacheKey] = extend({}, exceptions[cacheKey]);\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\n        \"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\"\n      );\n    }\n    return function (text, options2) {\n      options2 = options2 || {};\n      var localHyphenChar = keyOrDefault(\n          options2,\n          SETTING_NAME_HYPH_CHAR,\n          hyphenChar\n        ),\n        localMinWordLength =\n          keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >>\n          0,\n        localUserExceptions = keyOrDefault(\n          options2,\n          SETTING_NAME_EXCEPTIONS,\n          SETTING_DEFAULT_EXCEPTIONS,\n          validateArray\n        ),\n        cacheKey2 = localHyphenChar + localMinWordLength;\n      if (!exceptions[cacheKey2] && patternsDefinition[2]) {\n        exceptions[cacheKey2] = exceptionsFromDefinition(\n          patternsDefinition[2],\n          localHyphenChar\n        );\n        caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);\n      }\n      if (localUserExceptions && localUserExceptions.length) {\n        exceptions[cacheKey2] = extend(\n          exceptions[cacheKey2],\n          exceptionsFromDefinition(localUserExceptions, localHyphenChar)\n        );\n        markersDict = extend(\n          markersDict,\n          markersFromExceptionsDefinition(localUserExceptions)\n        );\n        caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);\n      }\n      return start(\n        text,\n        levelsTable,\n        patterns,\n        caches[cacheKey2],\n        markersDict,\n        localHyphenChar,\n        skipHTML,\n        localMinWordLength,\n        asyncMode\n      );\n    };\n  }\n\n  return createHyphenator;\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}